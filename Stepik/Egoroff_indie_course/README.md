«Инди-курс программирования на Python» от Атрёма Егорова

4.1 Знакомство с циклом while

В этом разделе мы познакомимся с еще одной новой для вас конструкцией языка программирования - циклом. Цикл, как и условный оператор, является важной частью структурного программирования. С помощью циклов можно организовать повторение выполнения участков кода. Потребность в этом возникает довольно часто. Например, пользователь будет повторять вводить свой пароль на сайте до тех пор, пока не введет правильный. Или, например, мы хотим написать программу, которая циклично для каждого номера, хранящегося у нас в телефонной книге, отправит смс. В этих примерах нам не обойтись без цикла.

В Python'е есть два основных цикла: цикл for и цикл while. Если программа хочет повторить отрывок кода определённое количество раз, она использует цикл for . Все остальные циклы делаются с помощью while.

В этом разделе мы познакомимся с циклом while.


<details>
<summary>Задачи:</summary>

<b>Задача:</b> Обратный счет
<details>
<summary>О задаче:</summary>
На вход программе поступает натуральное число N.
Ваша программа должна устроить обратный отсчет,
который стартует от числа N и идет до 0.
Перед непосредственно началом отсчета необходимо вывести фразу:

```
Начинаем отсчет
```
по окончанию отсчета распечатайте фразу:

```
Стартуем!
```

</details>

[Решение:](./while_cycle/return_invoice.py) `while_cycle/return_invoice.py`

<b>Задача:</b> Мишка и старший брат
<details>
<summary>О задаче:</summary>
Мишка Лимак хочет стать самым большим медведем,
ну или хотя бы стать больше своего старшего брата Боба.
Сейчас вес Лимака равен a, а вес Боба равен b.
Гарантируется, что вес Лимака меньше или равен весу Боба.
Лимак ест много, и его вес утраивается каждый год,
а вес Боба удваивается каждый год.
Через сколько целых лет Лимак станет строго больше
(т. е. будет весить строго больше) Боба?

#### Входные данные:
В единственной строке находятся два целых числа
a и b (1≤a≤b≤10) — веса Лимака и Боба соответственно.

#### Выходные данные:
Выведите одно целое число —
через сколько целых лет Лимак станет строго больше Боба.

### Примечание
В первом примере изначально вес Лимака равен 4, а вес Боба — 7.
Через год их веса равны 4·3=12 и 7·2=14 соответственно (один вес утроился, а второй удвоился).
Лимак все еще не больше Боба. Через два года их веса равны 36 и 28, то есть вес Лимака больше, чем вес Боба.
Лимак стал больше Боба через два года, поэтому вы должны вывести 2.

Во втором примере веса Лимака и Боба в последующие года равны: 12 и 18, затем 36 и 36, и наконец 108 и 72 (через три года).
Ответ равен 3. Помните, что Лимак хочет стать строго больше Боба, и его не устроят равные веса.

В третьем примере Лимак станет больше Боба через один год, их веса будут равны 3 и 2 соответственно.

Sample Input 1:<br>
4 7<br>
Sample Output 1:<br>
2<br>
Sample Input 2:<br>
4 9<br>
Sample Output 2:<br>
3<br>
Sample Input 3:<br>
1 1<br>
Sample Output 3:<br>
1

</details>

[Решение:](./while_cycle/bear_and_big_brother.py) `while_cycle/bear_and_big_brother.py`

<b>Задача:</b> Вася и носки
<details>
<summary>О задаче:</summary>
У Васи есть n пар носков. Утром каждого дня, собираясь в школу,
Вася должен надеть пару носков.
Вечером, прийдя со школы, Вася снимает надетые носки и выбрасывает их.
Каждый m-й день (в дни с номерами m,2m,3m,...)
мама покупает Васе одну пару носков. Она делает это поздно вечером,поэтому
Вася может надеть новые носки не раньше следующего дня.
На сколько подряд идущих дней Васе хватит носков?

#### Входные данные:
В единственной строке записано два целых числа
n и m (1≤n≤100; 2≤m≤100), разделенные пробелом.

#### Выходные данные:
Выведите единственное целое число — ответ на задачу.

### Примечание
В первом примере первые два дня Вася будет носить носки, которые у него были изначально,
затем на третий день будет носить носки, которые были куплены во второй день.
Во втором примере первые девять дней он будет носить носки,
которые у него были изначально, затем три дня будет носить носки,
которые были куплены в третий, шестой и девятый дни. Затем еще день будет носить носки,
которые были куплены в двенадцатый день.

Sample Input 1:<br>
2 2<br>
Sample Output 1:<br>
3<br>
Sample Input 2:<br>
9 3<br>
Sample Output 2:<br>
13

</details>

[Решение:](./while_cycle/vasya_and_socks.py) `while_cycle/vasya_and_socks.py`

<b>Задача:</b> Новогодние свечки
<details>
<summary>О задаче:</summary>
Программист Василий любит романтику — поэтому на этот Новый Год
он решил освещать свою комнату свечами.
У Василия есть a свечей.
Когда Василий зажигает новую свечу, сначала она горит ровно один час, а затем тухнет.
Василий — сообразительный малый, поэтому из b потухших свечей он умеет получать одну новую свечу.
В последствии эту новую свечу (так же как и другие новые свечи) можно зажечь.
<br><br>
Теперь Василию интересно, на сколько часов освещения хватит его свечек,
если он будет действовать оптимальным образом. Помогите ему найти это число.

#### Входные данные:
В единственной строке заданы два целых числа a и b (1≤a≤1000; 2≤b≤1000).

#### Выходные данные:
Выведите единственное целое число — количество часов, которое Василий сможет освещать комнату.

Sample Input:<br>
4 2<br>
Sample Output:<br>
7

</details>

[Решение:](./while_cycle/new_years_candles.py) `while_cycle/new_years_candles.py`

<b>Задача:</b> Зимний вечер в Бурсе
<details>
<summary>О задаче:</summary>
Зимний вечер в Бурсе
Возьмём число. Умножим его на его же первую цифру.
Результат умножим на первую цифру результата.
И так далее. Например, начнём с 8:<br><br>

8 → 8 * 8 = 64<br>
64 → 6 * 64 = 384<br>
384 → 3 * 384 = 1152<br>
1152 → 1 * 1152 = 1152<br><br>

Очевидно, когда первая цифра очередного числа в такой последовательности
становится равной 1, числа перестают изменяться.
Но это происходит не при всех начальных числах.

Напишем программу, которая будет хотя бы приблизительно определять судьбу
введённого числа n.

Начиная с числа n, умножайте имеющееся число на его первую цифру,
пока у получившегося числа первая цифра не станет равной 1,
либо пока оно не превысит миллиарда.
В качестве ответа выведите результат

Sample Input 1:<br>
8<br>
Sample Output 1:<br>
1152<br>
Sample Input 2:<br>
223<br>
Sample Output 2:<br>
1784<br>
Sample Input 3:<br>
929<br>
Sample Output 3:<br>
1605312<br>
Sample Input 4:<br>
360<br>
Sample Output 4:<br>
1080

</details>

[Решение:](./while_cycle/winter_evening_in_Bursa.py) `while_cycle/winter_evening_in_Bursa.py`

<b>Задача:</b> Гипотеза Коллатца
<details>
<summary>О задаче:</summary>
Сиракузская последовательность, или последовательность Коллатца, строится так: возьмём натуральное число n;
если оно чётное, то заменим его числом n/2; если же оно нечётное, то заменим его числом 3n+1.
Получившееся число — следующее в сиракузской последовательности после числа n. Затем заменяем получившееся число по тому же правилу, и так далее.
Определите, сколько шагов потребуется сиракузской последовательности,
стартующей с заданного числа, чтобы прийти к 1.

Обычно, если проделать такую замену достаточно много раз,
мы приходим к числу 1 (за которым следует снова 1).
<br>Например:
<br><br>
8 → 4 → 2 → 1 или 10 → 5 → 16 → 8 → 4 → 2 → 1.
<br><br>
Определите, сколько шагов потребуется сиракузской последовательности,
стартующей с заданного числа, чтобы прийти к 1.
<br>
Если вы обнаружите число, сиракузская последовательность от которого не приходит к 1,
то... вы, скорее всего, ошиблись.
Но если нет, то поздравляем: вы прославитесь, ведь вопрос о том, всегда ли сиракузская последовательность приходит к 1 (независимо от начального числа), давно будоражит умы математиков.

#### Входные данные:
В единственной строке заданы два целых числа a и b (1≤a≤1000; 2≤b≤1000).

#### Выходные данные:
Выведите единственное целое число — количество часов, которое Василий сможет освещать комнату.

Sample Input 1:<br>
10<br>
Sample Output 1:<br>
6<br>
Sample Input 2:<br>
16<br>
Sample Output 2:<br>
4

</details>

[Решение:](./while_cycle/collatz_hypothesis.py) `while_cycle/collatz_hypothesis.py`

<b>Задача:</b> Парольный дозор
<details>
<summary>О задаче:</summary>
На каждой отдельной строчке пользователь вводит друг за другом пароли в виде строки символов.
Валидными паролями будем считать строки, у которых длина варьируется от 5 до 9 символов включительно.
Как только вы встретите первый невалидный пароль, ваша программа должна закончить считывать пароли и
вывести последний введенный валидный пароль.
<br>
Гарантируется, что первый пароль всегда валидный

Sample Input 1:<br>
QWERTY<br>
12345<br>
21.08.90<br>
Кодзима-гений<br>
Телепузик<br><br>
Sample Output 1:<br>
21.08.90<br>
Sample Input 2:<br>
FDRE42@u<br>
*&#@732hH<br>
hi<br>
Hello<br>
OP213jf9@<br>
HFd23932<br><br>
Sample Output 2:<br>
*&#@732hH

</details>

[Решение:](./while_cycle/pass_watch.py) `while_cycle/pass_watch.py`

<b>Задача:</b> Герой на грани
<details>
<summary>О задаче:</summary>
Напишите программу, моделирующую изменение здоровья персонажа в игре.
Изначально у героя 100 единиц здоровья.
В ходе игры противник наносит удары, каждый из которых уменьшает здоровье персонажа
на определённое количество очков. Значения урона поступают на вход программе в отдельных строках.

Удары продолжаются до тех пор, пока здоровье персонажа не станет равным нулю или меньше нуля.
Пока герой не погиб, программа должна выводить текущий уровень здоровья в следующем формате:

```Уровень здоровья: {значение}```

Также необходимо вывести начальный уровень здоровья.

Окончания боя должно ознаменоваться сообщением

```Игра окончена.```

После этого программа должна сообщить общее количество ударов, которые выдержал персонаж, в формате:

```Количество ударов, которые ваш персонаж героически выдержал = {значение}```

А также указать номер последнего удара, который оказался критическим, в формате:

```Удар № {значение} был критическим```

Sample Input 1:<br>
20<br>
40<br>
60<br>
Sample Output 1:<br>
Уровень здоровья: 100<br>
Уровень здоровья: 80<br>
Уровень здоровья: 40<br>
Игра окончена.<br>
Количество ударов, которые ваш персонаж героически выдержал = 2<br>
Удар № 3 был критическим

</details>

[Решение:](./while_cycle/hero_on_the_edge.py) `while_cycle/hero_on_the_edge.py`

<b>Задача:</b> Очередь на взлёт
<details>
<summary>О задаче:</summary>
В аэропорту на стойке регистрации постоянно скапливается очередь клиентов.
Поэтому было принято решение организовать обслуживание таким образом,
чтобы клиенты могли видеть, кто следующий в очереди,
а также знать, сколько человек находится перед ними.
<br><br>
<b>Ваша задача<b> — написать программу, которая принимает список имён клиентов,
представляющий очередь. В начале списка находятся клиенты, стоящие в конце очереди,
а в конце списка — те, кто ближе к началу.
Программа должна выводить текстовые сообщения по мере продвижения очереди:

- для клиента, чья очередь наступила, выводится сообщение:<br>
```Клиент {name} пройдите к стойке!``` <br>

- для остальных клиентов выводится текст:<br>
```{Имена_оставшихся_в_очереди} ожидайте!``` <br>

Имена оставшихся клиентов указываются через запятую
в порядке их расположения в очереди<br>

Дополнительные требования:

1. Программа должна корректно обрабатывать списки любой длины;

2. Если список пуст, программа ничего не выводит;

3. Имена клиентов вводятся через пробел в одной строке.


Sample Input 1:<br>
Александр Елизавета Михаил Анастасия<br><br>
Sample Output 1:<br>
Клиент Анастасия пройдите к стойке!<br>
Михаил,Елизавета,Александр ожидайте!<br>
Клиент Михаил пройдите к стойке!<br>
Елизавета,Александр ожидайте!<br>
Клиент Елизавета пройдите к стойке!<br>
Александр ожидайте!<br>
Клиент Александр пройдите к стойке!<br><br>
Sample Input 2:<br>
John Emma Lucas Sophia Oliver<br><br>
Sample Output 2:<br>
Клиент Oliver пройдите к стойке!<br>
Sophia,Lucas,Emma,John ожидайте!<br>
Клиент Sophia пройдите к стойке!<br>
Lucas,Emma,John ожидайте!<br>
Клиент Lucas пройдите к стойке!<br>
Emma,John ожидайте!<br>
Клиент Emma пройдите к стойке!<br>
John ожидайте!<br>
Клиент John пройдите к стойке!

</details>

[Решение:](./while_cycle/queue_for_take-off.py) `while_cycle/queue_for_take-off.py`

<b>Задача:</b> Собираемся в поход
<details>
<summary>О задаче:</summary>
У нас в наличии рюкзак, вместимость которого составляет n литров,
и наша задача забить его до предела максимально возможно. Нам поступают вещи,
объем которых измеряется также в литрах, и мы должны их складывать в
наш рюкзак без возможности пропуска. Как только суммарный объем новой
добавляемой вещи превысит вместимость рюкзака, ваша программа должна
вывести слово "Довольно!" и затем на отдельных строчках суммарный объем вещей,
которые мы смогли упаковать в рюкзак, и их количество

#### Входные данные:
Число n – вместимость рюкзака. Далее идут произвольное количество строк –
объем очередного предмета.

#### Выходные данные:
Строка "Довольно!" и затем два числа – суммарный объем упакованных товаров и
их количество. Каждое значение выводится в отдельной строке.

Sample Input 1:<br>
2000<br>
900<br>
800<br>
700<br>
500<br>
200<br>
1000<br><br>
Sample Output 1:<br>
Довольно!<br>
1700<br>
2<br><br>

Sample Input 2:<br>
15<br>
1<br>
5<br>
6<br>
2<br>
1<br>
1<br>
1<br>
1<br>
7<br><br>
Sample Output 2:<br>
Довольно!<br>
15<br>
5

</details>

[Решение:](./while_cycle/hike.py) `while_cycle/hike.py`

<b>Задача:</b> Три удара и в блок
<details>
<summary>О задаче:</summary>
Напишите программу, которая имитирует систему аутентификации с ограниченным количеством попыток ввода пароля.

Пользователь вводит пароль, и ему предоставляется три попытки для успешного входа. При запуске программа должна запрашивать пароль у пользователя. Затем пользователь имеет три попытки для ввода правильного пароля. При каждой неудачной попытке программа уведомляет об этом и уменьшает лимит попыток, выводя следующие сообщения:

```Введен неправильный пароль!``` <br>
```Лимит попыток = {значение_лимита}```

Если пользователь вводит правильный пароль за отведённое количество попыток,
программа предоставляет доступ и выводит сообщение:

```Вы ввели правильный пароль! Добро пожаловать!```

Если все попытки исчерпаны, система блокируется на сутки,
и пользователю отображается сообщение:

```Вы потратили все свои попытки! Приходите завтра```

Sample Input 1:<br>
qwerty<br>
qwe<br>
qwerty<br><br>
Sample Output 1:<br>
Введен неправильный пароль!<br>
Лимит попыток = 2<br>
Вы ввели правильный пароль! Добро пожаловать!<br><br>
Sample Input 2:<br>
гром<br>
гром!<br>
гром24<br>
громозека<br><br>
Sample Output 2:<br>
Введен неправильный пароль!<br>
Лимит попыток = 2<br>
Введен неправильный пароль!<br>
Лимит попыток = 1<br>
Введен неправильный пароль!<br>
Лимит попыток = 0<br>
Вы потратили все свои попытки! Приходите завтра<br><br>
Sample Input 3:<br>
дом<br>
Дом<br>
ДОМ<br>
дом<br><br>
Sample Output 3:<br>
Введен неправильный пароль!<br>
Лимит попыток = 2<br>
Введен неправильный пароль!<br>
Лимит попыток = 1<br>
Вы ввели правильный пароль! Добро пожаловать!

</details>

[Решение:](./while_cycle/three_strikes.py) `while_cycle/three_strikes.py`

<b>Задача:</b> Новый год и спешка
<details>
<summary>О задаче:</summary>
В последний день уходящего 2016 года Лимак собирается принять участие
в соревновании по спортивному программированию. Соревнование начнётся в 20:00
и будет продолжаться четыре часа, то есть ровно до полуночи. Участникам будет предложено n задач,
упорядоченных по возрастанию сложности, то есть задача 1 будет самой лёгкой,
а задача номер n — самой сложной. Лимак знает, что ему потребуется 5·i минут на решение i-й задачи.

Друзья Лимака планируют устроить роскошную новогоднюю вечеринку,
и Лимак хочет прибыть в полночь или ранее. Он знает, что ему требуется ровно k минут
чтобы добраться до места проведения вечеринки от своего дома, где он собирается участвовать в соревновании.

Сколько максимум задач может успеть решить Лимак, чтобы не опоздать на новогоднюю вечеринку?

#### Входные данные:
В первой строке входных данных записаны два целых числа n и k (1 ≤ n ≤ 10, 1 ≤ k ≤ 240) — количество задач в соревновании и количество минут, за которое Лимак доберётся от дома до места проведения вечеринки.

#### Выходные данные:
Выведите одно целое число, равное максимальному количеству задач, которое может решить Лимак, чтобы прибыть на новогоднюю вечеринку ровно в полночь или раньше.

### Примечание

В первом примере на соревновании участникам предложено 3 задачи и Лимаку требуется 222 минуты,
чтобы доехать до места проведения вечеринки. Для решения задач требуется 5, 10 и 15 минут соответственно.
Лимак может решить первые две задачи, потратив на это 5 + 10 = 15 минут, после чего выехать в 20:15
и приехать на вечеринку в 23:57 (через 222 минуты). Таким образом он решит две задачи,
но на решение третьей времени уже не хватит и ответ равен 2.

Во втором примере Лимак может решить все 4 задачи за 5 + 10 + 15 + 20 = 50 минут.
В 20:50 он сможет выехать из дома и прибыть на вечеринку ровно в полночь.

В третьем примере Лимаку нужна только 1 минута, чтобы оказаться на вечеринке,
так что ему хватит времени для решения всех 7 задач.

Sample Input 1:<br>
3 222<br>
Sample Output 1:<br>
2<br>
Sample Input 2:<br>
4 190<br>
Sample Output 2:<br>
4<br>
Sample Input 3:<br>
7 1<br>
Sample Output 3:<br>
7<br>
Sample Input 4:<br>
1 240<br>
Sample Output 4:<br>
0<br>
Sample Input 5:<br>
10 1<br>
Sample Output 5:<br>
9<br>
Sample Input 6:<br>
9 235<br>
Sample Output 6:<br>
1

</details>

[Решение:](./while_cycle/new_year_rush.py) `while_cycle/new_year_rush.py`

<b>Задача:</b> Ваня и кубики
<details>
<summary>О задаче:</summary>
Ване на день рождения подарили n кубиков. Он с друзьями решил построить из них пирамиду. Ваня хочет построить пирамиду следующим образом: на верхушке пирамиды должен находиться 1 кубик, на втором уровне — 1 + 2 = 3 кубика, на третьем — 1 + 2 + 3 = 6 кубиков, и так далее. Таким образом, на i-м уровне пирамиды должно располагаться 1 + 2 + ... + (i - 1) + i кубиков.<br>

Ваня хочет узнать, пирамиду какой максимальной высоты он может создать с использованием имеющихся кубиков.

#### Входные данные:
В первой строке записано целое число n (1 ≤ n ≤ 104) — количество кубиков, подаренных Ване.

#### Выходные данные:
Выведите единственной строкой максимально возможную высоту пирамиды.

Sample Input 1:<br>
1<br>
Sample Output 1:<br>
1<br>
Sample Input 2:<br>
25<br>
Sample Output 2:<br>
4<br>
Sample Input 3:<br>
4<br>
Sample Output 3:<br>
2<br>
Sample Input 4:<br>
5<br>
Sample Output 4:<br>
2<br>
Sample Input 5:<br>
6560<br>
Sample Output 5:<br>
33<br>
Sample Input 6:<br>
3<br>
Sample Output 6:<br>
1

</details>

[Решение:](./while_cycle/cubes.py) `while_cycle/cubes.py`

<b>Задача:</b> Слияние списков
<details>
<summary>О задаче:</summary>
В вашем распоряжении имеются два списка, отсортированные по неубыванию элементов, состоящие из n и m элементов.

Ваша задача — слить их в один отсортированный список размером n + m при помощи алгоритма двух указателей.

#### Входные данные:
Программа получает на вход два числа n и m - количество элементов первого и второго списков.
Затем с новой строки поступают элементы первого отсортированного списка, а со следующей строки - второго списка.

#### Выходные данные:
Слить два списка в один в порядке неубывания и вывести элементы полученного списка

### P.S.:
Пользоваться встроенной сортировкой запрещено

Sample Input 1:<br>
2 3<br>
3 9<br>
2 3 6<br>
Sample Output 1:<br>
[2, 3, 3, 6, 9]<br><br>
Sample Input 2:<br>
3 5<br>
2 8 8<br>
3 4 5 5 10<br><br>
Sample Output 2:<br>
[2, 3, 4, 5, 5, 8, 8, 10]<br><br>
Sample Input 3:<br>
2 5<br>
3 7<br>
1 1 3 6 8<br>
Sample Output 3:<br>
[1, 1, 3, 3, 6, 7, 8]


</details>

[Решение:](./while_cycle/merging_lists_1.py) `while_cycle/merging_lists_1.py` <br>

[Альтернативное решение №1:](./while_cycle/merging_lists_2.py) `while_cycle/merging_lists_2.py` <br>

[Альтернативное решение №2:](./while_cycle/merging_lists_3.py) `while_cycle/merging_lists_3.py`

<b>Задача:</b> Бал в БерлГУ
<details>
<summary>О задаче:</summary>
По случаю 100500-летия Берляндского государственного университета совсем скоро состоится бал! Уже n юношей и m девушек во всю репетируют вальс, менуэт, полонез и кадриль.

Известно, что на бал будут приглашены несколько пар юноша-девушка, причем уровень умений танцевать партнеров в каждой паре должен отличаться не более чем на единицу.

Для каждого юноши известен уровень его умения танцевать. Аналогично, для каждой девушки известен уровень ее умения танцевать. Напишите программу, которая определит наибольшее количество пар, которое можно образовать из n юношей и m девушек.

#### Входные данные:
В первой строке записано целое число n (1 ≤ n ≤ 100) — количество юношей.
Вторая строка содержит последовательность a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub> (1 ≤ a<sub>i</sub> ≤ 100), где a<sub>i</sub> — умение танцевать i-го юноши.

Аналогично, третья строка содержит целое m (1 ≤ m ≤ 100) – количество девушек. В четвертой строке содержится последовательность b<sub>1</sub>, b<sub>2</sub>, ..., b<sub>m</sub> (1 ≤ b<sub>j</sub> ≤ 100), где b<sub>j</sub> — умение танцевать j-й девушки.

#### Выходные данные:
Выведите единственное число — искомое максимальное возможное количество пар.

#### Примечание
В первом примере можно сочетать к примеру так 1-1, 4-5, 6-7 либо 2-1, 4-5, 6-7. В любом случае можно составить только три пары

Sample Input 1:<br>
4<br>
1 4 6 2<br>
5<br>
5 1 5 7 9<br>
Sample Output 1:<br>
3<br><br>
Sample Input 2:<br>
4<br>
1 2 3 4<br>
4<br>
10 11 12 13<br>
Sample Output 2:<br>
0<br><br>
Sample Input 3:<br>
5<br>
1 1 1 1 1<br>
3<br>
1 2 3<br>
Sample Output 3:<br>
2<br><br>
Sample Input 4:<br>
4<br>
1 6 9 15<br>
2<br>
5 8<br>
Sample Output 4:<br>
2<br><br>
Sample Input 5:<br>
4<br>
3 3 5 5<br>
4<br>
4 4 2 2<br>
Sample Output 5:<br>
4

</details>

[Решение:](./while_cycle/ball.py) `while_cycle/ball.py`

</details>

4.6 Алгоритм Евклида

Алгоритм Евклида позволяет найти наибольший общий делитель (НОД) для двух чисел

Давайте сперва освежим память и вспомним, что такое делитель. Делитель натурального числа a – это натуральное число b, на которое число a делится нацело.

Например, делителем числа 6 являются числа: 1, 2, 3, 6.

Простым числом называется такое натуральное число, которое имеет два делителя: единица и само это число.
Например, простым числом будет являться число 5, так как у него только два делителя: 1 и 5. Также числа 7 и 13 будут являться простыми числами, а вот единица - нет. У единицы только один делитель, а должно быть два.

Общий делитель - это число, которое может быть делителем каждого числа из указанного множества.
Например, делители числа 10: 1, 2, 5, 10; а у числа 20: 1, 2, 4, 5, 10, 20. Общими делителями у 10 и 20 будут следующие числа: 1, 2, 5, 10.

...

<details>
<summary>Задачи:</summary>

<b>Задача:</b> Наибольший общий делитель

<details>
<summary>О задаче:</summary>
Даны два натуральных числа A и B. Требуется найти их наибольший общий делитель (НОД) методом вычитания.<br><br>

Sample Input 1:<br>
77 22<br>
Sample Output 1:<br>
11<br><br>
Sample Input 2:<br>
5 7<br>
Sample Output 2:<br>
1

</details>

[Решение:](./Euclids_algorithm/grcd_subtr.py) `Euclids_algorithm/grcd_subtr.py`

<b>Задача:</b> Наибольший общий делитель
<details>
<summary>О задаче:</summary>
Даны два натуральных числа A и B. Необходимо найти НОД двух чисел, только теперь нужно модернизировать свой код при помощи нахождения остатка от деления.<br><br>

Sample Input 1:<br>
200 30<br>
Sample Output 1:<br>
10<br><br>
Sample Input 2:<br>
10000 1<br>
Sample Output 2:<br>
1

</details>

[Решение:](./Euclids_algorithm/grcd.py) `Euclids_algorithm/grcd.py`

<b>Задача:</b> Наименьшее общее кратное
<details>
<summary>О задаче:</summary>
Даны два натуральных числа A и B. Требуется найти их наименьшее общее кратное (НОК).<br><br>

Sample Input 1:<br>
6 15<br>
Sample Output 1:<br>
30<br><br>
Sample Input 2:<br>
14 21<br>
Sample Output 2:<br>
42

</details>

[Решение:](./Euclids_algorithm/lecm.py) `Euclids_algorithm/lecm.py`<br>
[Альтернативное решение:](./Euclids_algorithm/lecm_2.py) `Euclids_algorithm/lecm_2.py`

</details>


5.2 Цикл for. Обход элементов функции range

Цикл for используется для последовательного обхода всех элементов итерируемого объекта.


<details>
<summary>Задачи:</summary>

<b>Задача:</b> FizzBuzz и цикл for
<details>
<summary>О задаче:</summary>
Давайте вспомним задачу FizzBuzz

Напишите программу, которая считывает два натуральных числа a и b (гарантируется, что a < b),
после чего для всех чисел от a до b включительно выводит:<br><br>

“Fizz”, если это число делится на 3;<br>
“Buzz”, если это число делится на 5;<br>
“FizzBuzz”, если выполнены оба предыдущих условия;<br>
само это число в остальных случаях.

#### Входные данные:
Два числа a и b, каждое на отдельной строке.

#### Выходные данные:
Для всех чисел от a до b напечатайте по одной строке, соответствующей правилам, описанным в условии.

Sample Input:<br>
9<br>
15<br><br>
Sample Output:<br>
Fizz<br>
Buzz<br>
11<br>
Fizz<br>
13<br>
14<br>
FizzBuzz

</details>

[Решение:](./for_cycle/fizzbuzz.py) `for_cycle/fizzbuzz.py`


<b>Задача:</b> Квадрат и куб
<details>
<summary>О задаче:</summary>
Давайте составим сводную информацию о квадратах и кубах интервала чисел.

На вход программе подаются два натуральных числа a и b (гарантируется, что a < b),
после чего для каждого целого числа на интервале от a до b включительно необходимо вывести фразу следующего вида:<br><br>

«Число {число}; его квадрат = {квадрат}; его куб = {куб}»<br>

Кавычки выводить не нужно и пользуйтесь f-строкой.

#### Входные данные:
На вход программе подается два натуральных числа a и b, каждое на отдельной строке.

#### Выходные данные:
Программа должна вывести текст в соответствии с условием задачи.<br><br>

Sample Input 1:<br>
1<br>
5<br><br>
Sample Output 1:<br>
Число 1; его квадрат = 1; его куб = 1<br>
Число 2; его квадрат = 4; его куб = 8<br>
Число 3; его квадрат = 9; его куб = 27<br>
Число 4; его квадрат = 16; его куб = 64<br>
Число 5; его квадрат = 25; его куб = 125<br><br>
Sample Input 2:<br>
35<br>
43<br><br>
Sample Output 2:<br>
Число 35; его квадрат = 1225; его куб = 42875<br>
Число 36; его квадрат = 1296; его куб = 46656<br>
Число 37; его квадрат = 1369; его куб = 50653<br>
Число 38; его квадрат = 1444; его куб = 54872<br>
Число 39; его квадрат = 1521; его куб = 59319<br>
Число 40; его квадрат = 1600; его куб = 64000<br>
Число 41; его квадрат = 1681; его куб = 68921<br>
Число 42; его квадрат = 1764; его куб = 74088<br>
Число 43; его квадрат = 1849; его куб = 79507

</details>

[Решение:](./for_cycle/square_and_cube.py) `for_cycle/square_and_cube.py`

<b>Задача:</b> Кратные 3 или 5
<details>
<summary>О задаче:</summary>
Если перечислить все натуральные числа ниже 10, которые кратны 3 или 5, то получим 3, 5, 6 и 9. Сумма этих чисел 23.

Напишите программу, которая принимает натуральное число n и находит сумму всех чисел ниже переданного числа n, которые делятся на 3 или на 5.

Sample Input 1:<br>
10<br>
Sample Output 1:<br>
23<br><br>
Sample Input 2:<br>
9<br>
Sample Output 2:<br>
14

</details>

[Решение:](./for_cycle/multiples_of_3_or_5.py) `for_cycle/multiples_of_3_or_5.py`

<b>Задача:</b> Пирамида звёздочек
<details>
<summary>О задаче:</summary>
Вы разрабатываете визуализацию для симметричных шаблонов.
Программа должна построить и вывести "песочные часы" из звёздочек.
Пользователь вводит одно число nnn, которое указывает максимальное количество звёздочек в самой широкой строке.

Напишите программу, которая:
1. Принимает на вход натуральное число n (n ≥ 1);

2. Выводит симметричный рисунок, состоящий из звёздочек:
    - В первых n строках звёздочки увеличиваются от 1 до n.
    - В следующих n-1 строках звёздочки уменьшаются от n-1 до 1.

Sample Input 1:<br>
5<br><br>
Sample Output 1:<br>
*<br>
**<br>
***<br>
****<br>
*****<br>
****<br>
***<br>
**<br>
*<br><br>
Sample Input 2:<br>
3<br><br>
Sample Output 2:<br>
*<br>
**<br>
***<br>
**<br>
*

</details>

[Решение:](./for_cycle/pyramid_of_stars.py) `for_cycle/pyramid_of_stars.py`

<b>Задача:</b> Мишка и игра
<details>
<summary>О задаче:</summary>
Мишка — маленький белый медвежонок. А как известно, маленькие медвежата в свободное время любят играть в кости на шоколадки.
Одним замечательным солнечным утром, гуляя по льдинам, Мишка встретил своего друга Криса, которому и предложил сыграть
в эту занимательную игру.

Правила её очень просты: сначала определяется значение n — количество раундов игры. В очередном раунде каждый из игроков
один раз бросает стандартный игральный кубик, на грани которого нанесены различные числа от 1 до 6.
Игрок, выбросивший большее значение, становится победителем в раунде. В случае, если выпавшие значения равны,
победа не засчитывается никому.

В самой же игре побеждает участник, выигравший в большем количестве раундов. Если же количества побед,
заслуженных игроками, равны, то объявляется ничья.

Мишка ещё совсем маленький и плохо умеет вести счёт, а потому попросил Вас понаблюдать за ходом игры
и сообщить ему результат.

#### Входные данные:

В первой строке входных данных содержится число n (1 ≤ n ≤ 100) — количество раундов игры.

Следующие n строк содержат описание раундов. В <i>i-й</i> из них содержится пара целых чисел m<sub>i</sub> и c<sub>i</sub> (1 ≤ m<sub>i</sub>, c<sub>i</sub> ≤ 6) —
результаты бросков Мишки и Криса в <i>i-ом</i> раунде соответственно.

#### Выходные данные:

В случае победы Мишки в единственной строке выведите "Mishka" (без кавычек),<br>
а в случае победы Криса выведите "Chris" (без кавычек). Если же игра сведётся к ничьей,<br>
то выведите "Friendship is magic!^^" (без кавычек).<br>

### PS:
генерировать случайные числа (пользоваться модулем random) вам не нужно, данные для игры уже готовы.<br>
Вам нужно только их считать,  и узнать, кто же победил.

Sample Input 1:<br>
3<br>
3 5<br>
2 1<br>
4 2<br><br>
Sample Output 1:<br>
Mishka<br><br>
Sample Input 2:<br>
2<br>
6 1<br>
1 6<br><br>
Sample Output 2:<br>
Friendship is magic!^^<br><br>
Sample Input 3:<br>
3<br>
1 5<br>
3 3<br>
2 2<br><br>
Sample Output 3:<br>
Chris<br><br>
Sample Input 4:<br>
3<br>
6 1<br>
1 2<br>
1 2<br><br>
Sample Output 4:<br>
Chris<br><br>
Sample Input 5:<br>
3<br>
1 6<br>
2 1<br>
2 1<br><br>
Sample Output 5:<br>
Mishka<br><br>
Sample Input 6:<br>
3<br>
1 6<br>
2 1<br>
1 1<br><br>
Sample Output 6:<br>
Friendship is magic!^^

</details>

[Решение:](./for_cycle/Mishka_and_a_game.py) `for_cycle/Mishka_and_a_game.py`

<b>Задача:</b> Слишком длинные слова
<details>
<summary>О задаче:</summary>
Иногда некоторые слова вроде «civilization» или «internationalization» настолько длинны,
что их весьма утомительно писать много раз в каком-либо тексте.

Будем считать слово слишком длинным, если его длина строго больше 10 символов.
Все слишком длинные слова можно заменить специальной аббревиатурой.

Эта аббревиатура строится следующим образом: записывается первая и последняя буква слова,
а между ними — количество букв между первой и последней буквой (в десятичной системе счисления и без ведущих нулей).

Таким образом, «civilization» запишется как «c10n», а «internationalization» как «i18n».

Вам предлагается автоматизировать процесс замены слов на аббревиатуры.
При этом все слишком длинные слова должны быть заменены аббревиатурой, а слова,
не являющиеся слишком длинными, должны остаться без изменений.

#### Входные данные:
В первой строке содержится целое число n (1≤n≤100). В каждой из последующих n строк содержится по одному слову.
Все слова состоят из малых латинских букв и имеют длину от 1 до 100 символов.

#### Выходные данные:
Выведите n строк. В i строке должен находиться результат замены i-го слова из входных данных.

Sample Input 1:<br>
4<br>
word<br>
civilization<br>
internationalization<br>
pneumonoultramicroscopicsilicovolcanoconiosis<br><br>

Sample Output 1:<br>
word<br>
c10n<br>
i18n<br>
p43s<br><br>

Sample Input 2:<br>
10<br>
gyartjdxxlcl<br>
fzsck<br>
uidwu<br>
xbymclornemdmtj<br>
ilppyoapitawgje<br>
cibzc<br>
drgbeu<br>
hezplmsdekhhbo<br>
feuzlrimbqbytdu<br>
kgdco<br><br>

Sample Output 2:<br>
g10l<br>
fzsck<br>
uidwu<br>
x13j<br>
i13e<br>
cibzc<br>
drgbeu<br>
h12o<br>
f13u<br>
kgdco

</details>

[Решение:](./for_cycle/too_long_words.py) `for_cycle/too_long_words.py`

<b>Задача:</b> Заполняем список
<details>
<summary>О задаче:</summary>
Ваша задача — создать список из n строк. Программа сперва будет принимать натуральное число n,
а затем n строк в каждой отдельной строке. В качестве ответа выведите получившийся список.

Sample Input 1:<br>
4<br>
Джон<br>
Пол<br>
Ринго<br>
Джордж<br><br>

Sample Output 1:<br>
['Джон', 'Пол', 'Ринго', 'Джордж']<br><br>

Sample Input 2:<br>
2<br>
black<br>
white<br><br>
Sample Output 2:<br>
['black', 'white']

</details>

[Решение:](./for_cycle/list_filling.py) `for_cycle/list_filling.py`

<b>Задача:</b> Делимость на 11
<details>
<summary>О задаче:</summary>
Для делимости числа на 11 необходимо, чтобы разность между суммой цифр, стоящих на четных местах, и суммой цифр, стоящих на нечетных местах, делилась на 11.
Требуется написать программу, которая проверит делимость заданного числа на 11.

#### Входные данные:
Программа получает на вход одно натуральное число N, делимость которого надо проверить (1 ≤ N ≤ 1010000).

#### Выходные данные:
Выведите «YES», если число делится на 11, или «NO» иначе.

Sample Input 1:<br>
1211<br><br>

Sample Output 1:<br>
NO<br><br>

Sample Input 2:<br>
143<br><br>

Sample Output 2:<br>
YES<br><br>

Sample Input 3:<br>
87635064<br><br>

Sample Output 3:<br>
YES<br><br>

Sample Input 4:<br>
87635063<br><br>

Sample Output 4:<br>
NO

</details>

[Решение:](./for_cycle/divisibility_by_11.py) `for_cycle/divisibility_by_11.py`

<b>Задача:</b> Правильная скобочная последовательность
<details>
<summary>О задаче:</summary>
Одна из стандартных задач на программирование. Подумайте над способом ее решения, если не приходит ничего в голову, загляните в подсказку
Итак, у нас есть последовательность скобочных символов, состоящая только из символов ( и )
Ваша задача — определить является ли введенная скобочная последовательность правильной.
Правильной скобочной последовательностью (ПСП) называется строка, состоящая только символов «скобок», где каждой закрывающей скобке найдётся соответствующая открывающая. При этом учитывайте, что:

Пустая последовательность является правильной;
Если A – правильная скобочная последовательность, то (A) – правильные скобочные последовательности;
Если A и B – правильные скобочные последовательности, то AB – правильная скобочная последовательность.
Если введенная строка является ПСП, выведите «YES», в противном случае - «NO».

Sample Input 1:<br>
(())<br><br>
Sample Output 1:<br>
YES<br><br>
Sample Input 2:<br>
(()<br><br>
Sample Output 2:<br>
NO<br><br>
Sample Input 3:<br>
())<br><br>
Sample Output 3:<br>
NO<br><br>
Sample Input 4:<br>
()()<br><br>
Sample Output 4:<br>
YES<br><br>
Sample Input 5:<br>
))((<br><br>
Sample Output 5:<br>
NO<br><br>
Sample Input 6:<br>
()())<br><br>
Sample Output 6:<br>
NO<br><br>
Sample Input 7:<br>
)(<br><br>
Sample Output 7:<br>
NO

</details>

[Решение:](./for_cycle/divisibility_by_11.py) `for_cycle/divisibility_by_11.py`

<b>Задача:</b> Всё в порядке с операциями?
<details>
<summary>О задаче:</summary>
Вы работаете в аналитической компании, которая обрабатывает финансовые данные.
Вам нужно написать программу, которая проверяет список транзакций (чисел) и определяет,
все ли они положительные. Если хотя бы одна транзакция отрицательная или равна нулю,
программа должна немедленно вывести False. Если все транзакции положительные, выводит True.

Список чисел поступает через пробел в одну строку, гарантируется,
что как минимум он состоит из одной транзакции.

Sample Input 1:<br>
100 200 50 75<br><br>

Sample Output 1:<br>
True<br><br>

Sample Input 2:<br>
150 -10 200 50<br><br>

Sample Output 2:<br>
False<br><br>

Sample Input 3:<br>
0 100 200<br><br>

Sample Output 3:<br>
False

</details>

[Решение:](./for_cycle/operations_is_ok.py) `for_cycle/operations_is_ok1.py`

<b>Задача:</b> Линейный поиск
<details>
<summary>О задаче:</summary>
Линейный поиск,
также известный как последовательный поиск,
этот метод используется для поиска элемента в списке.
Линейный поиск является одним из базовых алгоритмов,
с которым вы должны познакомиться, изучая программирования.
Суть алгоритма в следующем: вы должны проверять каждый
элемент списка последовательно один за другим,
пока не найдете интересующий вас элемент или пока не закончится весь список.

#### Входные данные:
Программа получает на вход в одной строке
элементы списка - целые числа, разделенные пробелом.
Количество элементов произвольное
И на следующей строке вводится одно число r - значение поиска

#### Выходные данные:
Ваша задача реализовать линейный алгоритм поиска введенного значения r.
В случае успеха - выведите порядковый номер(индекс) первого найденного элемента
в списке при условии, что индексация начинается с единицы.
Если данный элемент отсутствует - необходимо вывести строку ErrorValue

Sample Input 1:<br>
8 11 45 32 543 65<br>
32<br><br>

Sample Output 1:<br>
4<br><br>

Sample Input 2:<br>
5 5 5 5<br>
5<br><br>

Sample Output 2:<br>
1<br><br>

Sample Input 3:<br>
32 4 543 65 4 5 4 54 32 5 54 43 543 43<br>
999<br><br>

Sample Output 3:<br>
ErrorValue

</details>

[Решение:](./for_cycle/linear_search.py) `for_cycle/linear_search.py`
[Альтернативное Решение:](./for_cycle/linear_search_alt.py) `for_cycle/linear_search_alt.py`

</details>
